
#include "InertialFilter.h"

/************************************************
 * GENERATED via ./genInertialFilterMatrices.py *
 ************************************************/

void InertialFilter::initMatrices(bool in_simulation) {
  if (!in_simulation) {
    A = NMatrix(4,4,false);
    A[0][0]= 1.000000e+00; A[0][1]= 1.000000e-02; A[0][2]= 5.000000e-05; A[0][3]= 0.000000e+00; 
    A[1][0]= 0.000000e+00; A[1][1]= 1.000000e+00; A[1][2]= 1.000000e-02; A[1][3]= 0.000000e+00; 
    A[2][0]= 0.000000e+00; A[2][1]= 0.000000e+00; A[2][2]= 1.000000e+00; A[2][3]= 0.000000e+00; 
    A[3][0]= 0.000000e+00; A[3][1]= 0.000000e+00; A[3][2]= 0.000000e+00; A[3][3]= 1.000000e+00; 

    B = NMatrix(4,2,false);
    B[0][0]= 1.666667e-07; B[0][1]= 0.000000e+00; 
    B[1][0]= 5.000000e-05; B[1][1]= 0.000000e+00; 
    B[2][0]= 1.000000e-02; B[2][1]= 0.000000e+00; 
    B[3][0]= 0.000000e+00; B[3][1]= 1.000000e+00; 

    C = NMatrix(2,4,false);
    C[0][0]= 9.810000e+00; C[0][1]= 0.000000e+00; C[0][2]= 3.000000e-01; C[0][3]= 0.000000e+00; 
    C[1][0]= 0.000000e+00; C[1][1]= 1.000000e+00; C[1][2]= 0.000000e+00; C[1][3]= 1.000000e+00; 

    Cz = NMatrix(1,4,false);
    Cz[0][0]= 1.000000e+00; Cz[0][1]= 0.000000e+00; Cz[0][2]= 0.000000e+00; Cz[0][3]= 0.000000e+00; 

    Cz1 = NMatrix(1,4,false);
    Cz1[0][0]= 0.000000e+00; Cz1[0][1]= 1.000000e+00; Cz1[0][2]= 0.000000e+00; Cz1[0][3]= 0.000000e+00; 

    Q = NMatrix(4,4,false);
    Q[0][0]= 2.500000e-13; Q[0][1]= 7.500000e-11; Q[0][2]= 1.500000e-08; Q[0][3]= 0.000000e+00; 
    Q[1][0]= 7.500000e-11; Q[1][1]= 2.250000e-08; Q[1][2]= 4.500000e-06; Q[1][3]= 0.000000e+00; 
    Q[2][0]= 1.500000e-08; Q[2][1]= 4.500000e-06; Q[2][2]= 9.000000e-04; Q[2][3]= 0.000000e+00; 
    Q[3][0]= 0.000000e+00; Q[3][1]= 0.000000e+00; Q[3][2]= 0.000000e+00; Q[3][3]= 1.000000e-08; 

    R = NMatrix(2,2,false);
    R[0][0]= 1.089000e-01; R[0][1]= 0.000000e+00; 
    R[1][0]= 0.000000e+00; R[1][1]= 3.046174e-04; 

    L = NMatrix(4,2,false);
    L[0][0]= 8.951342e-04; L[0][1]= 4.405798e-03; 
    L[1][0]= 1.673560e-03; L[1][1]= 1.624577e-01; 
    L[2][0]= 2.358349e-02; L[2][1]= 1.504474e+00; 
    L[3][0]=-2.901578e-04; L[3][1]= 1.515192e-03; 

  }
  if (in_simulation) {
    A = NMatrix(4,4,false);
    A[0][0]= 1.000000e+00; A[0][1]= 2.000000e-02; A[0][2]= 2.000000e-04; A[0][3]= 0.000000e+00; 
    A[1][0]= 0.000000e+00; A[1][1]= 1.000000e+00; A[1][2]= 2.000000e-02; A[1][3]= 0.000000e+00; 
    A[2][0]= 0.000000e+00; A[2][1]= 0.000000e+00; A[2][2]= 1.000000e+00; A[2][3]= 0.000000e+00; 
    A[3][0]= 0.000000e+00; A[3][1]= 0.000000e+00; A[3][2]= 0.000000e+00; A[3][3]= 1.000000e+00; 

    B = NMatrix(4,2,false);
    B[0][0]= 1.333333e-06; B[0][1]= 0.000000e+00; 
    B[1][0]= 2.000000e-04; B[1][1]= 0.000000e+00; 
    B[2][0]= 2.000000e-02; B[2][1]= 0.000000e+00; 
    B[3][0]= 0.000000e+00; B[3][1]= 1.000000e+00; 

    C = NMatrix(2,4,false);
    C[0][0]= 9.810000e+00; C[0][1]= 0.000000e+00; C[0][2]= 3.000000e-01; C[0][3]= 0.000000e+00; 
    C[1][0]= 0.000000e+00; C[1][1]= 1.000000e+00; C[1][2]= 0.000000e+00; C[1][3]= 1.000000e+00; 

    Cz = NMatrix(1,4,false);
    Cz[0][0]= 1.000000e+00; Cz[0][1]= 0.000000e+00; Cz[0][2]= 0.000000e+00; Cz[0][3]= 0.000000e+00; 

    Cz1 = NMatrix(1,4,false);
    Cz1[0][0]= 0.000000e+00; Cz1[0][1]= 1.000000e+00; Cz1[0][2]= 0.000000e+00; Cz1[0][3]= 0.000000e+00; 

    Q = NMatrix(4,4,false);
    Q[0][0]= 1.600000e-11; Q[0][1]= 2.400000e-09; Q[0][2]= 2.400000e-07; Q[0][3]= 0.000000e+00; 
    Q[1][0]= 2.400000e-09; Q[1][1]= 3.600000e-07; Q[1][2]= 3.600000e-05; Q[1][3]= 0.000000e+00; 
    Q[2][0]= 2.400000e-07; Q[2][1]= 3.600000e-05; Q[2][2]= 3.600000e-03; Q[2][3]= 0.000000e+00; 
    Q[3][0]= 0.000000e+00; Q[3][1]= 0.000000e+00; Q[3][2]= 0.000000e+00; Q[3][3]= 1.000000e-08; 

    R = NMatrix(2,2,false);
    R[0][0]= 1.089000e-01; R[0][1]= 0.000000e+00; 
    R[1][0]= 0.000000e+00; R[1][1]= 3.046174e-04; 

    L = NMatrix(4,2,false);
    L[0][0]= 1.433561e-03; L[0][1]= 9.441112e-03; 
    L[1][0]= 2.846235e-03; L[1][1]= 2.983561e-01; 
    L[2][0]= 4.484365e-02; L[2][1]= 2.738228e+00; 
    L[3][0]=-2.893348e-04; L[3][1]= 1.468981e-03; 

  }

}

void InertialFilter::updateIUHeight(float torsoZ) {
  // torso (which is actually between hip) + 85mm (from specs) - gyro offset
  float iu_height = (torsoZ + 85) * 0.001 - 0.029; // convert to m
  C[0][2] = iu_height;
  //std::cout << "iu_height = " << iu_height << std::endl;
}

